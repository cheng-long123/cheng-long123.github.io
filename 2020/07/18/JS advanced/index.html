<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>javaScript高级 | Bubble</title><meta name="description" content="javaScripr高级javaScriptjavascript是什么？ 解析执行：轻量级解释型的 解释执行 JavaScript PHP 每一行代码都要先解释再执行 – 慢，灵活   var a &#x3D; 10;  var b &#x3D; 20;  console.log(a, b); 编译执行 C# Java 一次性编译，然后再一行一行执行 – 快  语言特点：动态，头等函数 (First-class Fu"><meta name="keywords" content="javascript"><meta name="author" content="Bubble"><meta name="copyright" content="Bubble"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/2020/07/18/JS%20advanced/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="javaScript高级"><meta property="og:url" content="http://example.com/2020/07/18/JS%20advanced/"><meta property="og:site_name" content="Bubble"><meta property="og:description" content="javaScripr高级javaScriptjavascript是什么？ 解析执行：轻量级解释型的 解释执行 JavaScript PHP 每一行代码都要先解释再执行 – 慢，灵活   var a &#x3D; 10;  var b &#x3D; 20;  console.log(a, b); 编译执行 C# Java 一次性编译，然后再一行一行执行 – 快  语言特点：动态，头等函数 (First-class Fu"><meta property="og:image" content="http://img.netbian.com/file/2020/0621/smalla1148d5bf834637922f9b176842795ec1592744024.jpg"><meta property="article:published_time" content="2020-07-17T16:00:00.000Z"><meta property="article:modified_time" content="2020-09-10T09:48:10.958Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-10 17:48:10'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'true'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@master/hexo/css/GalMenu.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/flink.min.css"><meta name="generator" content="Hexo 5.1.1"></head><body>
<div id='loader'>
    
    <div class="outer_box">
        <div class='loader_overlay'></div>
        <div class='loader_cogs'>
            <div class='loader_cogs__top'>
                <div class='top_part'></div>
                <div class='top_part'></div>
                <div class='top_part'></div>
                <div class='top_hole'></div>
            </div>
            <div class='loader_cogs__left'>
                <div class='left_part'></div>
                <div class='left_part'></div>
                <div class='left_part'></div>
                <div class='left_hole'></div>
            </div>
            <div class='loader_cogs__bottom'>
                <div class='bottom_part'></div>
                <div class='bottom_part'></div>
                <div class='bottom_part'></div>
                <div class='bottom_hole'></div>
            </div>
            <p style="text-align:center">&nbsp;&nbsp;&nbsp;loading...</p>
        </div>
    </div>
    
</div>

<script>
    var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
    }
    window.addEventListener('load', endLoading);
</script>
<div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/articles/"><i class="fa-fw fas fa-book"></i><span> 文章</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 好书</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#javaScripr%E9%AB%98%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">javaScripr高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#javaScript"><span class="toc-number">1.1.</span> <span class="toc-text">javaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">javascript是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">javascript组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">浏览器是如何工作的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javaScipt%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">javaScipt面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">面向对象介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">什么是对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">什么是面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%93%E7%8E%B0"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">程序中面向对象的基本体现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">简单方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">解析构造函数代码的执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E4%BE%8B-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">构造函数和对象(实例)的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">实例成员和静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">构造函数、实例、原型三者之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%88%90%E5%91%98%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8E%9F%E5%88%99%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">属性成员的搜索原则：原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%AF%BB%E5%86%99%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">实例对象读写原型对象成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E5%8E%9F%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">更简单的原型语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">原生对象的原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">原型对象使用建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%9D%97%E6%B8%B8%E6%88%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">案例：随机方块游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">自调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.6.</span> <span class="toc-text">什么是继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9D%E7%BB%A7%E6%89%BF%E2%80%9D"><span class="toc-number">1.2.7.</span> <span class="toc-text">对象的”继承”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.8.</span> <span class="toc-text">原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.</span> <span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%9A%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.10.</span> <span class="toc-text">组合继承：原型继承+借用构造函数继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-number">1.3.</span> <span class="toc-text">函数进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数的定义方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-Function"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">new Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">函数声明与函数表达式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">函数的调用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85-this-%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数内 this 指向的不同场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B9%9F%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.4.</span> <span class="toc-text">函数也是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.3.5.</span> <span class="toc-text">改变函数中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B6%E5%AE%83%E6%88%90%E5%91%98"><span class="toc-number">1.3.6.</span> <span class="toc-text">函数的其它成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.7.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">作为参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">作为返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.8.</span> <span class="toc-text">作用域、作用域链、预解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">1.3.9.</span> <span class="toc-text">什么是闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">一些关于闭包的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">闭包的思考题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.3.10.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">递归执行模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%EF%BC%9A%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E7%9A%84%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">举个栗子：计算阶乘的递归函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">递归应用场景</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(http://img.netbian.com/file/2020/0621/smalla1148d5bf834637922f9b176842795ec1592744024.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Bubble</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/articles/"><i class="fa-fw fas fa-book"></i><span> 文章</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 好书</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">javaScript高级</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-17T16:00:00.000Z" title="发表于 2020-07-18 00:00:00">2020-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-10T09:48:10.958Z" title="更新于 2020-09-10 17:48:10">2020-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web/">web</a></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="javaScripr高级"><a href="#javaScripr高级" class="headerlink" title="javaScripr高级"></a>javaScripr高级</h1><h2 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h2><h3 id="javascript是什么？"><a href="#javascript是什么？" class="headerlink" title="javascript是什么？"></a>javascript是什么？</h3><ul>
<li><p>解析执行：轻量级解释型的</p>
<p>解释执行 JavaScript PHP 每一行代码都要先解释再执行 – 慢，灵活</p>
<a id="more"></a>
<p> var a = 10;</p>
<p> var b = 20;</p>
<p> console.log(a, b);</p>
<p>编译执行 C# Java 一次性编译，然后再一行一行执行 – 快</p>
</li>
<li><p>语言特点：动态，头等函数 (First-class Function)</p>
</li>
</ul>
<ul>
<li>又称函数是 JavaScript 中的一等公民</li>
</ul>
<ul>
<li><p>执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境</p>
<ul>
<li>但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js</li>
</ul>
</li>
</ul>
<h3 id="javascript组成"><a href="#javascript组成" class="headerlink" title="javascript组成"></a>javascript组成</h3><ul>
<li>ECMAScript - 语法规范<ul>
<li>变量、数据类型、类型转换、操作符</li>
<li>流程控制语句：判断、循环语句</li>
<li>数组、函数、作用域、预解析</li>
<li>对象、属性、方法、简单类型和复杂类型的区别</li>
<li>内置对象：Math、Date、Array，基本包装类型String、Number、Boolean</li>
</ul>
</li>
<li>Web APIs<ul>
<li>BOM<ul>
<li>onload页面加载事件，window顶级对象</li>
<li>定时器</li>
<li>location、history</li>
</ul>
</li>
<li>DOM<ul>
<li>获取页面元素，注册事件</li>
<li>属性操作，样式操作</li>
<li>节点属性，节点层级</li>
<li>动态创建元素</li>
<li>事件：注册事件的方式、事件的三个阶段、事件对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="浏览器是如何工作的"><a href="#浏览器是如何工作的" class="headerlink" title="浏览器是如何工作的"></a>浏览器是如何工作的</h3><p>![浏览器是如何工作的](D:\cheng\myBlog\source_posts\img\浏览器工作 .png)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User Interface  用户界面，我们所看到的浏览器</span><br><span class="line">Browser engine  浏览器引擎，用来查询和操作渲染引擎</span><br><span class="line">*Rendering engine 用来显示请求的内容，负责解析HTML、CSS，并把解析的内容显示出来。</span><br><span class="line">                负责把HTML文档解释成DOM树</span><br><span class="line">Networking   网络，负责发送网络请求</span><br><span class="line">*JavaScript Interpreter(解析者)   JavaScript解析器，负责执行JavaScript的代码</span><br><span class="line">UI Backend   UI后端，用来绘制类似组合框和弹出窗口</span><br><span class="line">Data Persistence(持久化)  数据持久化，数据存储  cookie、HTML5中的sessionStorage</span><br></pre></td></tr></table></figure>

<h2 id="javaScipt面向对象编程"><a href="#javaScipt面向对象编程" class="headerlink" title="javaScipt面向对象编程"></a>javaScipt面向对象编程</h2><h3 id="面向对象介绍"><a href="#面向对象介绍" class="headerlink" title="面向对象介绍"></a>面向对象介绍</h3><h4 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a><strong>什么是对象</strong></h4><ul>
<li><p><strong>现实世界中的对象</strong></p>
<p>对象是单个事 物的抽象。</p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
</li>
<li><p><strong>程序世界中的对象</strong></p>
<p>对象是一个容器，封装了属性（property）和方法（method）。</p>
<ul>
<li>属性是对象的状态，方法是对象的行为（完成某种任务）。<ul>
<li>比如：我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</li>
</ul>
</li>
<li>对象是一个抽象的概念，可以将其简单理解为：<strong>数据集或功能集</strong>。</li>
<li>ECMAScript-262 把对象定义为：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。</li>
</ul>
<blockquote>
<p>提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</p>
<p>Array 类型 构造函数</p>
<p>var arr = new Array();</p>
</blockquote>
<p>Student 一类事物 类型</p>
<p>var s = new Student(); 通过类型，创建了一个具体的对象</p>
</li>
</ul>
<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><blockquote>
<p>面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于<strong>提高</strong>代码的<strong>开发效率</strong>和<strong>可维护性</strong>。</p>
</blockquote>
<ul>
<li><p>面向对象编程</p>
<p>Object Oriented Programming，简称 OOP ，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
</li>
<li><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有<strong>明确分工</strong>，可以完成接受信息、处理数据、发出信息等任务。对象要<strong>职责分明</strong></p>
</li>
</ul>
<blockquote>
<p>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
</blockquote>
<p>面向对象与面向过程：</p>
<ul>
<li>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊</li>
<li>面向对象就是找一个对象，指挥得结果</li>
<li>面向对象将执行者转变成指挥者</li>
<li><strong>面向对象不是面向过程的替代，而是面向过程的封装</strong></li>
</ul>
<p><strong>面向对象的特性</strong>：</p>
<ul>
<li>封装性</li>
<li>继承性</li>
<li>[多态性]抽象</li>
</ul>
<h4 id="程序中面向对象的基本体现"><a href="#程序中面向对象的基本体现" class="headerlink" title="程序中面向对象的基本体现"></a>程序中面向对象的基本体现</h4><p>在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。 自定义的对象数据类型就是面向对象中的类（ Class ）的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> std1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="attr">score</span>: <span class="number">98</span> &#125;</span><br><span class="line"><span class="keyword">var</span> std2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">score</span>: <span class="number">81</span> &#125;</span><br></pre></td></tr></table></figure>

<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printScore</span> (<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;姓名：&#x27;</span> + student.name + <span class="string">&#x27;  &#x27;</span> + <span class="string">&#x27;成绩：&#x27;</span> + student.score)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程， 而是 <code>Student</code> 这种数据类型应该被视为一个对象，这个对象拥有 <code>name</code> 和 <code>score</code> 这两个属性（Property）。 如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 <code>printScore</code> 消息，让对象自己把自己的数据打印出来。</p>
<p>抽象数据行为模板（Class）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">  <span class="built_in">this</span>.printScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;姓名：&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;  &#x27;</span> + <span class="string">&#x27;成绩：&#x27;</span> + <span class="built_in">this</span>.score);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据模板创建具体实例对象（Instance）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> std1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">98</span>)</span><br><span class="line"><span class="keyword">var</span> std2 = <span class="keyword">new</span> Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">81</span>)</span><br></pre></td></tr></table></figure>

<p>实例对象具有自己的具体行为（给对象发消息）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std1.printScore() <span class="comment">// =&gt; 姓名：Michael  成绩：98</span></span><br><span class="line">std2.printScore() <span class="comment">// =&gt; 姓名：Bob  成绩 81</span></span><br></pre></td></tr></table></figure>

<p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。 Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念， 而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。</p>
<p>所以，面向对象的设计思想是：</p>
<ul>
<li>抽象出 Class(构造函数)</li>
<li>根据 Class(构造函数) 创建 Instance</li>
<li>指挥 Instance 得结果</li>
</ul>
<p>面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="简单方式"><a href="#简单方式" class="headerlink" title="简单方式"></a>简单方式</h4><p>我们可以直接通过 <code>new Object()</code> 创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次创建通过 <code>new Object()</code> 比较麻烦，所以可以通过它的简写形式对象字面量来创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的写法固然没有问题，但是假如我们要生成两个 <code>person</code> 实例对象呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Mike&#x27;</span>,</span><br><span class="line">  age: <span class="number">16</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>内容引导：</p>
<ul>
<li>构造函数语法</li>
<li>分析构造函数</li>
<li>构造函数和实例对象的关系<ul>
<li>实例的 constructor 属性</li>
<li>instanceof 操作符</li>
</ul>
</li>
<li>普通函数调用和构造函数调用的区别</li>
<li>构造函数的问题</li>
</ul>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">p1.sayName(); <span class="comment">// =&gt; Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName(); <span class="comment">// =&gt; Mike</span></span><br></pre></td></tr></table></figure>

<h4 id="解析构造函数代码的执行"><a href="#解析构造函数代码的执行" class="headerlink" title="解析构造函数代码的执行"></a>解析构造函数代码的执行</h4><p>而要创建 <code>Person</code> 实例，则必须使用 <code>new</code> 操作符。 以这种方式调用构造函数会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>下面是具体的伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象</span></span><br><span class="line">  <span class="comment">// var instance = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// 然后让内部的 this 指向 instance 对象</span></span><br><span class="line">  <span class="comment">// this = instance</span></span><br><span class="line">  <span class="comment">// 接下来所有针对 this 的操作实际上操作的就是 instance</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在函数的结尾处会将 this 返回，也就是 instance</span></span><br><span class="line">  <span class="comment">// return this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数和对象-实例-的关系"><a href="#构造函数和对象-实例-的关系" class="headerlink" title="构造函数和对象(实例)的关系"></a>构造函数和对象(实例)的关系</h4><p>在每一个实例对象中同时有一个 <code>constructor</code> 属性，该属性指向创建该实例的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.constructor === Person); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor === p2.constructor); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>对象的 <code>constructor</code> 属性最初是用来标识对象类型的， 但是，如果要检测对象的类型，还是使用 <code>instanceof</code> 操作符更可靠一些：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>构造函数是根据具体的事物抽象出来的抽象<strong>模板</strong></p>
</li>
<li><p>实例对象是根据抽象的构造函数模板得到的具体实例对象</p>
</li>
<li><p>每一个实例对象都具有一个</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor</span><br></pre></td></tr></table></figure>



<p>  属性，指向创建该实例的构造函数</p>
<ul>
<li>注意： <code>constructor</code> 是实例的属性的说法不严谨，具体后面的原型会讲到</li>
</ul>
<ul>
<li>可以通过实例的</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor</span><br></pre></td></tr></table></figure>



<p>  属性判断实例和构造函数之间的关系</p>
<ul>
<li>注意：这种方式不严谨，推荐使用 <code>instanceof</code> 操作符，后面学原型会解释为什么</li>
</ul>
<h4 id="实例成员和静态成员"><a href="#实例成员和静态成员" class="headerlink" title="实例成员和静态成员"></a>实例成员和静态成员</h4><ul>
<li><p>实例成员</p>
<p>属于对象的成员，每一个对象都具有的成员，但是每个对象具有的这个成员的值是不同的。</p>
<p>例如：p.name。通过Person构造函数创建的对象的name属性的值是不同的</p>
</li>
<li><p>静态成员</p>
<p>属于构造函数的成员，所有对象都共享</p>
<p>Person.verson = ‘1.0’;</p>
</li>
</ul>
<h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;human&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。 那就是对于每一个实例对象，<code>type</code> 和 <code>sayHello</code> 都是一模一样的内容， 每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>对于这种问题我们可以把需要共享的函数定义到构造函数外部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> = <span class="title">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;human&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.sayHello = sayHello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Top&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li><strong>构造函数的原型</strong></li>
</ul>
<p>更好的解决对象中方法占用内容的方式的方案： <strong>prototype</strong></p>
<p>JavaScript 规定，每一个**(构造)函数<strong>都有一个 **prototype</strong> 属性，指向另一个对象。 <strong>这个对象的所有属性和方法，都会被构造函数的对象所拥有</strong>。</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"></span><br><span class="line">Person.prototype.type = <span class="string">&#x27;human&#x27;</span></span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(...)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>这时所有实例的 <code>type</code> 属性和 <code>sayName()</code> 方法， 其实都是同一个内存地址，指向 <strong>prototype</strong> 对象，因此就提高了运行效率。</p>
<ul>
<li><p><strong>对象的原型</strong></p>
<p>每一个对象都有一个<strong><strong>proto</strong></strong>的属性，此属性指向构造函数的<strong>prototype</strong></p>
<blockquote>
<p><strong>注意</strong>：<code>__proto__</code> 是非标准属性。</p>
</blockquote>
</li>
</ul>
<h4 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h4><p><img src= "/img/loading.gif" data-lazy-src="https://lixiaohui100200.github.io/assets/img/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AE%9E%E4%BE%8B-%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="img"></p>
<p>任何函数都具有一个 <strong>prototype</strong> 属性，该属性是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数的 <code>prototype</code> 对象默认都有一个 <strong>constructor</strong> 属性，指向 <strong>prototype</strong> 对象所在函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.prototype.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>实例对象可以直接访问原型对象成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.sayHi() <span class="comment">// =&gt; hi!</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象</li>
<li><code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数</li>
<li>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></li>
<li>所有实例都直接或间接继承了原型对象的成员</li>
</ul>
<h4 id="属性成员的搜索原则：原型链"><a href="#属性成员的搜索原则：原型链" class="headerlink" title="属性成员的搜索原则：原型链"></a>属性成员的搜索原则：原型链</h4><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p>
<ul>
<li>搜索首先从对象实例本身开始</li>
<li>如果在实例中找到了具有给定名字的属性，则返回该属性的值</li>
<li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</li>
<li>如果在原型对象中找到了这个属性，则返回该属性的值</li>
</ul>
<p>也就是说，在我们调用 <code>person1.sayName()</code> 的时候，会先后执行两次搜索：</p>
<ul>
<li>首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。</li>
<li>”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。</li>
<li>”于是，它就读取那个保存在原型对象中的函数。</li>
<li>当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。</li>
</ul>
<p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<p>总结：</p>
<ul>
<li>先在自己身上找，找到即返回</li>
<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>
<li>如果一直到原型链的末端还没有找到<ul>
<li>如果是属性则返回 <code>undefined</code></li>
<li>如果是方法会报错</li>
</ul>
</li>
</ul>
<h4 id="实例对象读写原型对象成员"><a href="#实例对象读写原型对象成员" class="headerlink" title="实例对象读写原型对象成员"></a>实例对象读写原型对象成员</h4><p>读取：</p>
<ul>
<li>先在自己身上找，找到即返回</li>
<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>
<li>如果一直到原型链的末端还没有找到<ul>
<li>如果是属性则返回 <code>undefined</code></li>
<li>如果是方法会报错</li>
</ul>
</li>
</ul>
<p>写入：</p>
<ul>
<li>当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上</li>
<li>也就是说该行为实际上会屏蔽掉对原型对象成员的访问</li>
</ul>
<h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h4><p>我们注意到，前面例子中每添加一个属性和方法就要敲一遍 <code>Person.prototype</code> 。 为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  type: <span class="string">&#x27;human&#x27;</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;，我今年&#x27;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27;岁了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该示例中，我们将 <code>Person.prototype</code> 重置到了一个新的对象。 这样做的好处就是为 <code>Person.prototype</code> 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 <code>constructor</code> 成员。</p>
<p>所以，我们为了保持 <code>constructor</code> 的指向正确，建议的写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // =&gt; 手动将 <span class="keyword">constructor</span> 指向正确的构造函数</span><br><span class="line">  type: &#x27;human&#x27;,</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;，我今年&#x27;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27;岁了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h4><p>所有函数都有 prototype 属性对象。</p>
<ul>
<li>Object.prototype</li>
<li>Function.prototype</li>
<li>Array.prototype</li>
<li>String.prototype</li>
<li>Number.prototype</li>
<li>Date.prototype</li>
<li>…</li>
</ul>
<blockquote>
<p><strong>注意</strong>：内置对象的<strong>prototype</strong>属性(只读属性)不能够直接复制</p>
</blockquote>
<h4 id="原型对象使用建议"><a href="#原型对象使用建议" class="headerlink" title="原型对象使用建议"></a>原型对象使用建议</h4><ul>
<li>属性（一般就是非函数成员）放到构造函数中</li>
<li>方法（一般就是函数）放到原型对象中</li>
<li>如果重置了 <code>prototype</code> 记得修正 <code>constructor</code> 的指向</li>
</ul>
<h3 id="案例：随机方块游戏"><a href="#案例：随机方块游戏" class="headerlink" title="案例：随机方块游戏"></a>案例：随机方块游戏</h3><ul>
<li><p>分析对象：方块对象 Box</p>
</li>
<li><p>分析属性和方法</p>
<ul>
<li>属性<ul>
<li>left、top 方块的坐标</li>
<li>size 方块的大小（方块是正方形的）</li>
<li>color 方块的颜色</li>
<li>_div 方块对应的div</li>
</ul>
</li>
<li>方法<ul>
<li>random 随机生成位置</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数</p>
<p>构造函数中设置方块的属性，创建div</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.left = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.top = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.size = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">this</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  map.appendChild(<span class="built_in">this</span>.div);</span><br><span class="line">  <span class="built_in">this</span>.div.className = <span class="string">&#x27;box&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机方块的位置</p>
<ol>
<li>随机生成方块的坐标，范围在map中</li>
<li>随机生成方块的颜色</li>
<li>设置div的样式属性</li>
<li>构造函数中调用random</li>
<li>新建app.js创建方块进行测试</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Box.prototype.random = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 随机生成坐标</span></span><br><span class="line">  <span class="keyword">var</span> maxX = <span class="number">800</span> / <span class="built_in">this</span>.size - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> maxY = <span class="number">600</span> / <span class="built_in">this</span>.size - <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.left = getRandom(<span class="number">0</span>, maxX) * <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">this</span>.top = getRandom(<span class="number">0</span>, maxY) * <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 2. 随机生成颜色</span></span><br><span class="line">  <span class="keyword">var</span> r = getRandom(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">var</span> g = getRandom(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">var</span> b = getRandom(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="built_in">this</span>.color = <span class="string">&#x27;rgb(&#x27;</span>+ r +<span class="string">&#x27;, &#x27;</span>+ g +<span class="string">&#x27;, &#x27;</span>+ b +<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  <span class="comment">// 3. 设置div的样式属性</span></span><br><span class="line">  <span class="built_in">this</span>.div.style.left = <span class="built_in">this</span>.left + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.div.style.top = <span class="built_in">this</span>.top + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.div.style.width = <span class="built_in">this</span>.size + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.div.style.height = <span class="built_in">this</span>.size + <span class="string">&#x27;px&#x27;</span>;  </span><br><span class="line">  <span class="built_in">this</span>.div.style.backgroundColor = <span class="built_in">this</span>.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机生成[min, max]之间的整数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>游戏主逻辑</p>
<ol>
<li><p>创建方块对象</p>
</li>
<li><p>开启定时器，定时随机方块的位置</p>
</li>
<li><p>点击map，判断鼠标的位置是否在方块上</p>
<p>3.1 获取鼠标在map中的坐标</p>
<p>3.2 判断鼠标的位置是否在方块上，如果赢了，停止定时器</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><ul>
<li><p>自调用函数</p>
<ul>
<li><p>解决变量冲突的问题</p>
</li>
<li><p>问题：演示不加分号的问题</p>
</li>
<li><p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> msg = <span class="string">&#x27;你猜谁能访问我&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(msg);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>函数要使用()包含起来，把函数变成表达式</li>
<li>后面的小括号是函数调用</li>
</ul>
</blockquote>
</li>
<li><p>问题</p>
<ul>
<li><p>问题1：如果存在多个自调用函数要用分号分割，否则语法错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题2：当自调用函数 前面有函数声明时，会出错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以建议自调用函数前，加上;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;22&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>bind改变函数中的this</p>
<ul>
<li><p>定时器中的this指向谁？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何把定时器中的this改变成其它对象？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;.bind(obj), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>bind() 可以改变函数内部的this的指向，并返回一个新的函数</p>
</blockquote>
</li>
</ul>
<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul>
<li>现实生活中的继承</li>
<li>程序中的继承<ul>
<li>子类型继承父类型的成员，让代码重用</li>
</ul>
</li>
</ul>
<h3 id="对象的”继承”"><a href="#对象的”继承”" class="headerlink" title="对象的”继承”"></a>对象的”继承”</h3><p>通过遍历把一个对象的所有成员拷贝给另一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的拷贝</span></span><br><span class="line"><span class="comment">// 复制对象的成员给另一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="comment">// 不复制同名的属性</span></span><br><span class="line">    <span class="keyword">if</span> (child[key]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    child[key] = parent[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><ul>
<li>继承：类型和类型之间的关系</li>
<li>学生类型 老师类型 -&gt; Person类型</li>
<li>继承目的： 把子类型中共同的成员提取到父类型中，代码重用</li>
<li>可以方便的基础父类型的原型中的方法，但是属性的继承无意义</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="built_in">this</span>.sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;大家好，我是&#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.score = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当设置了构造函数的prototype之后，别忘记设置constructor</p>
<p>问题：原型继承，无法设置构造函数的参数**Student.prototype = new Person();**只执行一次，无法给属性传值</p>
</blockquote>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><ul>
<li><p>前置知识 call</p>
<p>使用call可以改变函数中的this，并且可以立即调用函数</p>
<p>和bind不同的是，bind会返回一个新函数，而call是直接调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call()  改变函数中的this，直接调用函数</span></span><br><span class="line">fn.call(o, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>借用构造函数</p>
<p>可以方便的继承父类型的属性，但是无法继承原型中的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age, sex);</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(s1);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>借用构造函数继承的问题：无法继承方法</p>
</blockquote>
</li>
</ul>
<h3 id="组合继承：原型继承-借用构造函数继承"><a href="#组合继承：原型继承-借用构造函数继承" class="headerlink" title="组合继承：原型继承+借用构造函数继承"></a>组合继承：原型继承+借用构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;大家好，我是&#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age, sex);</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"><span class="comment">// 学生特有的方法</span></span><br><span class="line">Student.prototype.exam = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;考试&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结</strong>：</p>
<p>继承：子类型所有对象具有父类型的成员</p>
<p>关于继承要记住下面两句代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h3><ul>
<li>函数声明</li>
<li>函数表达式</li>
<li><code>new Function</code></li>
</ul>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a><strong>new Function</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b;&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sum = fn(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>

<h4 id="函数声明与函数表达式的区别"><a href="#函数声明与函数表达式的区别" class="headerlink" title="函数声明与函数表达式的区别"></a>函数声明与函数表达式的区别</h4><ul>
<li>函数声明必须有名字</li>
<li><strong>函数声明会函数提升</strong>，在预解析阶段就已创建，声明前后都可以调用</li>
<li>函数表达式类似于变量赋值，提升的仅仅是变量声明</li>
<li>函数表达式可以没有名字，例如匿名函数</li>
<li>函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用</li>
</ul>
<p>下面是一个根据条件定义函数的例子(了解)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果在不同浏览器中结果不一致。有些浏览器里不会进行函数提升(Chrome)，有些浏览器中会函数提升。</p>
<p>不过我们可以使用函数表达式解决上面的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h3><ul>
<li>普通函数</li>
<li>构造函数</li>
<li>对象方法</li>
</ul>
<h3 id="函数内-this-指向的不同场景"><a href="#函数内-this-指向的不同场景" class="headerlink" title="函数内 this 指向的不同场景"></a>函数内 <code>this</code> 指向的不同场景</h3><p>函数的调用方式决定了 <code>this</code> 指向的不同：</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>非严格模式</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数调用</td>
<td>window</td>
<td>严格模式下是 undefined</td>
</tr>
<tr>
<td>构造函数调用</td>
<td>实例对象</td>
<td>原型方法中 this 也是实例对象</td>
</tr>
<tr>
<td>对象方法调用</td>
<td>该方法所属对象</td>
<td>紧挨着的对象</td>
</tr>
<tr>
<td>事件绑定方法</td>
<td>绑定事件对象</td>
<td></td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
<td></td>
</tr>
</tbody></table>
<p>这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。</p>
<blockquote>
<p><strong>注意</strong>：<strong>函数内部的this，是由函数的调用方式决定的。</strong></p>
</blockquote>
<h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><ul>
<li>所有函数都是 <code>Function</code> 的实例</li>
</ul>
<h3 id="改变函数中的this"><a href="#改变函数中的this" class="headerlink" title="改变函数中的this"></a>改变函数中的this</h3><ul>
<li><p>为什么要改变函数内部的this</p>
<p>例如：我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。</p>
</li>
<li><p>函数有三个方法可以改变内部的this：call、apply、bind。</p>
</li>
</ul>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和分别地提供的参数(参数的列表)。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>thisArg</code><ul>
<li>在 fun 函数运行时指定的 this 值</li>
<li>如果指定了 null 或者 undefined 则内部 this 指向 window</li>
</ul>
</li>
<li><code>arg1, arg2, ...</code><ul>
<li>指定的参数列表</li>
</ul>
</li>
</ul>
<p>应用：</p>
<ol>
<li><p>借用构造函数</p>
</li>
<li><p>借用其他对象的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪数组</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">11</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">20</span>,</span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(obj, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(obj, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用Object的toString()</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>thisArg</code></li>
<li><code>argsArray</code></li>
</ul>
<p><code>apply()</code> 与 <code>call()</code> 非常相似，不同之处在于提供参数的方式。 <code>apply()</code> 使用参数数组而不是一组参数列表。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(<span class="built_in">this</span>, [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>应用：把数组展开</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math.max(3, 5, 6);</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// Math.max不能求数组中的最大值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr));</span><br><span class="line"><span class="comment">// console.log(1, 2, 3);</span></span><br><span class="line"><span class="comment">// console.log(arr);</span></span><br><span class="line"><span class="built_in">console</span>.log.apply(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, arr);</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><ul>
<li>bind不会调用函数，会返回一个新的函数</li>
<li>新函数内部的this是bind的第一个参数</li>
<li>原函数中的参数，通过第二个参数传递</li>
</ul>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>thisArg<ul>
<li>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
</ul>
</li>
<li>arg1, arg2, …<ul>
<li>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<p>返回由指定的this值和初始化参数改造的原函数拷贝。</p>
<p>示例1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  fun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fun();</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件处理函数中的this  是触发该事件的对象</span></span><br><span class="line">  <span class="comment">// 通过bind 改变事件处理函数中this的指向</span></span><br><span class="line">&#125;.bind(obj);</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>call 和 apply 特性一样<ul>
<li>都是用来调用函数，而且是立即调用</li>
<li>但是可以在调用函数的同时，通过第一个参数指定函数内部 <code>this</code> 的指向</li>
<li>call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可</li>
<li>apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递</li>
<li>如果第一个参数指定了 <code>null</code> 或者 <code>undefined</code> 则内部 this 指向 window</li>
</ul>
</li>
<li>bind<ul>
<li>可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数</li>
<li>它和 call、apply 最大的区别是：bind 不会调用</li>
<li>bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递<ul>
<li><ol>
<li>在 bind 的同时，以参数列表的形式进行传递</li>
</ol>
</li>
<li><ol>
<li>在调用的时候，以参数列表的形式进行传递</li>
</ol>
</li>
<li>那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准</li>
<li>两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="函数的其它成员"><a href="#函数的其它成员" class="headerlink" title="函数的其它成员"></a>函数的其它成员</h3><ul>
<li><ul>
<li>实参集合</li>
</ul>
</li>
<li>caller<ul>
<li>函数的调用者</li>
</ul>
</li>
<li>length<ul>
<li>形参的个数</li>
</ul>
</li>
<li>name<ul>
<li>函数的名称</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn.length) <span class="comment">// =&gt; 形参的个数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// 伪数组实参参数集合</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === fn) <span class="comment">// 函数本身</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn.caller) <span class="comment">// 函数的调用者</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn.name) <span class="comment">// =&gt; 函数的名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul>
<li>函数可以作为参数</li>
<li>函数可以作为返回值</li>
</ul>
<h4 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;吃完了&#x27;</span>)</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eat(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;去唱歌&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="作为返回值"><a href="#作为返回值" class="headerlink" title="作为返回值"></a>作为返回值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genFun</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isArray = genFun(<span class="string">&#x27;[object Array]&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isObject = genFun(<span class="string">&#x27;[object Object]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isArray([])); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArray(&#123;&#125;)); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域、作用域链、预解析"><a href="#作用域、作用域链、预解析" class="headerlink" title="作用域、作用域链、预解析"></a>作用域、作用域链、预解析</h3><ul>
<li>函数作用域</li>
<li><strong>没有块级作用域</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>作用域链示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">40</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c + d);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn1();</span><br><span class="line">  fn2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p><strong>闭包</strong>：闭包是函数和声明该函数的词法环境的组合。</p>
<ul>
<li>闭包就是能够读取其他函数内部变量的函数，</li>
<li>闭包就是将函数内部和函数外部连接起来的一座桥梁。</li>
</ul>
<p>闭包的用途：</p>
<ul>
<li>可以在函数外部读取函数内部成员</li>
<li>让函数内成员始终存活在内存中</li>
</ul>
<h4 id="一些关于闭包的例子"><a href="#一些关于闭包的例子" class="headerlink" title="一些关于闭包的例子"></a>一些关于闭包的例子</h4><p>闭包演示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br></pre></td></tr></table></figure>

<p>案例1：第一次调用生成一个随机数，以后每次调用都返回这个随机数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> random = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> random; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = getRandom();</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br></pre></td></tr></table></figure>

<p>案例2：写一个函数返回一个返回，返回的函数可以实现1+m, 100+m, 1000+m</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFun</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求 100 + m</span></span><br><span class="line"><span class="keyword">var</span> fn100 = getFun(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 求 1000 + m</span></span><br><span class="line"><span class="keyword">var</span> fn1000 = getFun(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fn100(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn1000(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>案例3：闭包的经典案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heroes = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;heroes&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> list = heroes.children;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = list[i];</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    li.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 点击li的时候输出当前li对应的索引</span></span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例4：点击按钮设置文档字体大小</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数，设置body的字体大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFun</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style.fontSize = size + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn1.onclick = makeFun(<span class="number">12</span>);</span><br><span class="line">btn2.onclick = makeFun(<span class="number">14</span>);</span><br><span class="line">btn3.onclick = makeFun(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>案例5：定时器输出循环变量i</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>setTimeout的执行原理</p>
<p>所有的js代码都在执行栈上执行，定时器和注册事件的函数会放到一个任务队列上。</p>
<p>当执行栈上的代码执行完毕后，才会执行任务队列上的任务。</p>
</li>
</ul>
<h4 id="闭包的思考题"><a href="#闭包的思考题" class="headerlink" title="闭包的思考题"></a>闭包的思考题</h4><p>思考题 1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())</span><br></pre></td></tr></table></figure>

<p>思考题 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;　　</span><br><span class="line"><span class="keyword">var</span> object = &#123;　　　　</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()())</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>什么是递归<ul>
<li>函数自己调用自己</li>
<li>递归需要有结束的条件</li>
</ul>
</li>
</ul>
<h4 id="递归执行模型"><a href="#递归执行模型" class="headerlink" title="递归执行模型"></a>递归执行模型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">  fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">  fn3()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">333</span>)</span><br><span class="line">  fn4()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">444</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn4&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br></pre></td></tr></table></figure>

<h4 id="举个栗子：计算阶乘的递归函数"><a href="#举个栗子：计算阶乘的递归函数" class="headerlink" title="举个栗子：计算阶乘的递归函数"></a>举个栗子：计算阶乘的递归函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归应用场景"><a href="#递归应用场景" class="headerlink" title="递归应用场景"></a>递归应用场景</h4><ul>
<li><p>深拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">o1, o2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o1[key] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果key是数组类型 Array？   []</span></span><br><span class="line">      o2[key] = [];</span><br><span class="line">      deepCopy(o1[key], o2[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1[key] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果key是复杂类型 Object？  &#123;&#125;</span></span><br><span class="line">      o2[key] = &#123;&#125;;</span><br><span class="line">      deepCopy(o1[key], o2[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果key这个属性 是基本类型</span></span><br><span class="line">      o2[key] = o1[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>遍历 DOM 树</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Bubble</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/07/18/JS%20advanced/">http://example.com/2020/07/18/JS%20advanced/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Bubble</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javascript/">javascript</a></div><div class="post_share"><div class="social-share" data-image="http://img.netbian.com/file/2020/0621/smalla1148d5bf834637922f9b176842795ec1592744024.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/23/js2020ms/"><img class="prev-cover" data-lazy-src="https://p.ananas.chaoxing.com/star3/origin/88067b872c1a292a5da9f65e8cf2d436.jpg?rw=1920&amp;rh=1080&amp;_fileSize=68370&amp;_orientation=1" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">js面试题</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/18/dom%20bom/"><img class="next-cover" data-lazy-src="https://p.ananas.chaoxing.com/star3/origin/1857f5a5b8e99fbe23678362decbc82f.jpg?rw=1920&amp;rh=1080&amp;_fileSize=139168&amp;_orientation=1" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">dom/bom操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/10/promise/" title="Promise"><img class="cover" data-lazy-src="https://p.ananas.chaoxing.com/star3/origin/42cd5a6514ca98e18315d268cb3d794b.jpg?rw=1920&rh=1080&_fileSize=260708&_orientation=1"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-10</div><div class="title">Promise</div></div></a></div><div><a href="/2020/07/17/whaist-js/" title="javaScript基础"><img class="cover" data-lazy-src="http://img.netbian.com/file/2020/0704/small2c43bc50d1acd18e7d1436585f3eab0a1593869774.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="title">javaScript基础</div></div></a></div><div><a href="/2020/07/18/dom bom/" title="dom/bom操作"><img class="cover" data-lazy-src="https://p.ananas.chaoxing.com/star3/origin/1857f5a5b8e99fbe23678362decbc82f.jpg?rw=1920&rh=1080&_fileSize=139168&_orientation=1"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-18</div><div class="title">dom/bom操作</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></article></main><footer id="footer" style="background-image: url(http://img.netbian.com/file/2020/0621/smalla1148d5bf834637922f9b176842795ec1592744024.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Bubble</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我相信我可以，但我一直在路上，所以我有无限的可能！！</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'ybhJ9PRkKn4TNp1Aazo3rPzA-gzGzoHsz',
      appKey: 'RV5MOnLiGIhvupwpe0u6D3SI',
      placeholder: '📌昵称可以填写QQ号来自动补全QQ信息啦~\r👨‍🔧本站已启用Akismet反垃圾评论~\r🚀评论和回复支持M↓~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2020/07/18/JS%20advanced/'
    this.page.identifier = '2020/07/18/JS advanced/'
    this.page.title = 'javaScript高级'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/title.js"></script><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/js/upjiang.js"></script><script src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/js/circleMagic.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@master/hexo/css/GalMenu.css"><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159935113525" m="1"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script><script src="./js/third-party/fish.js"></script><script src="./js/calendar.js"></script><script src="./js/calendar2.js"></script><script src="./js/xkTool.js"></script><script src="./js/snbg.js"></script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})


document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div>
<div class="GalMenu GalDropDown">
    <div class="circle" id="gal">
        <div class="ring">
            <a href="/" class="menuItem">首页</a>
            <a href="javascript:history.go(1);" class="menuItem">前进</a>
            <a href="javascript:$('html,body').animate({scrollTop:0},500);" class="menuItem">顶部</a>
            <a href="javascript:location.reload();" class="menuItem">刷新</a>
            <a href="/Message/" class="menuItem">留言</a>
            <a href="javascript:history.go(-1);" class="menuItem">后退</a>
        </div>
        
        <audio id="audio" src="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@master/hexo/audio/niconiconi.mp3"></audio>
        
    </div>
</div>
<script type="text/javascript">
    var items = document.querySelectorAll('.menuItem');
    for (var i = 0, l = items.length; i < l; i++) {
        items[i].style.left = (50 - 35 * Math.cos(-0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
        items[i].style.top = (50 + 35 * Math.sin(-0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }
</script>
<script>
    window.jQuery || document.write(
            '<script src="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@master/hexo/js/jquery-2.1.1.min.js">
</script>')</script>

<script src="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@master/hexo/js/GalMenu.js"></script>

<script type="text/javascript">
    $(document).ready(function () {
        $('body').GalMenu({
            'menu': 'GalDropDown'
        })
    });
</script>
<link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script></body></html>